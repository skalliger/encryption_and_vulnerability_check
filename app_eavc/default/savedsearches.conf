[default]
[populate_linux_kernel_lookup]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = * */12 * * *
dispatch.earliest_time = 0
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = app_eavc
request.ui_dispatch_view = search
search = index=app_eavc sourcetype="eavc:kernel_versions"\
| table kernel_version, releaseDate, latest, latestReleaseDate, lts, eol, \
| sort - releaseDate\
| outputlookup linux_kernel_versions.csv

[populate_manual_checks_lookup]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
description = Run this Check once and set checkDone to yes after confirming the configs.
dispatch.earliest_time = @d
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
search = | inputlookup svd_mitigation\
| fields svd_id, note\
    ``` \
    In order to get all SVDs only once, we have seperated the SVDs into Splunk Enterprise, Apps and Universal Forwarders \
    Enterprise = upgradeNecessary, mitFlag\
    Apps/Add-ons = upgradeNecessary2, mitFlag2\
    UFs = upgradeNecessary3, mitFlag3\
    ``` \
| lookup svd_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary, mitFlag \
| lookup svd_app_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary2, mitFlag AS mitFlag2 \
| lookup svd_uf_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary3, mitFlag AS mitFlag3\
    ``` \
    This lookup gets populated by manually(!) running the "populate_manual_checks_lookup" report. After that, put in the lookup which ones you have checked.\
    Or simply modify the report to output a yes in the checkDone column. ``` \
| lookup svd_manual_checks svd_id AS svd_id OUTPUTNEW checkDone AS checkDone \
    ``` \
    The checks here aren't that hard, except for one situation. When we have multiple target releases for a fix AND our version is exactly one of them, we ran into issues in the past. \
    That's why we set an additional flag ONLY if our current version is exactly the same as the required version (as there are probably mutliple fixed versions listed in an SVD). \
    In that case, we don't need all the other release checks.\
    ``` \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary3), upgradeNecessary2, upgradeNecessary) \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), upgradeNecessary3, upgradeNecessary) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag3), mitFlag2, mitFlag) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag2), mitFlag3, mitFlag) \
| eval dd = mvdedup(upgradeNecessary) \
| eval ddMit = mvdedup(mitFlag) \
| fields - mitFlag, mitFlag* \
| eval dd=if(match(ddMit, "mitigated"), "no", if(match(upgradeNecessary, "yes"), "yes", dd)) \
| eval check = case(\
    ``` OLD - need to verify this works now without checking for "no" and "NOT yes": we check for yes AND no due to checking against multiple releases. if one verison has a "yes", we need to upgrade ```\
    ``` dd=="no" AND dd!="yes", "mitigated", ```\
    dd=="no", "mitigated",\
    dd=="yes", "vulnerable",\
    dd=="not installed", "not installed",\
    isnull(dd), "manual check",\
    1==1, "unknown"\
    ) \
    ``` get PYTHONHTTPS ``` \
| join type=left svd_id \
    [| search index=app_eavc sourcetype="eavc:python_https" PYTHONHTTPSVERIFY!="0" earliest=-14d@d \
    | stats latest(PYTHONHTTPSVERIFY) AS status \
    | eval status = case (\
        status=0, "disabled",\
        status=1, "enabled",\
        status=="enabled", status,\
        status=="disabled", status,\
        1==1, "unknown"\
        ) \
    | eval mitigated = case(\
        status=="enabled", "mitigated",\
        status=="disabled", vulnerable,\
        1==1, "unknown"\
        ) \
    | eval svd_id="SVD-2022-0601" \
    | fields svd_id, mitigated \
    | rename mitigated AS pyMitigation ] \
    ``` get Deployment Server authentication-related SVDs ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_ds_auth" earliest=-14d@d \
    | fields server, stanza, config, requireAuthentication \
    | eval DSAuthenticationInUse = case( \
        stanza=="broker:broker" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="streams:deployment" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="broker:broker" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        stanza=="streams:deployment" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        1==1, "unknown"\
        ) \
    | eval svd_id= mvappend("SVD-2022-0608", "SVD-2022-0607") \
    | stats values(DSAuthenticationInUse) AS DSAuthInUse by svd_id \
    | table svd_id, DSAuthInUse \
    | eval dsStatus = case(\
        DSAuthInUse=="no", "vulnerable",\
        DSAuthInUse=="yes", "mitigated",\
        1==1, "unknown"\
        ) \
    | fields svd_id, dsStatus ] \
``` SVD-2022-0601, SVD-2022-0602, SVD-2022-0603, SVD-2022-0606 ```\
| join type=left svd_id \
    [ | search index="app_eavc" sourcetype="eavc:mc_tls_verification" stanza="*" server="*" earliest=-14d@d\
| fields svd_id, mitigationStatus, server, stanza, *Verify*\
| table svd_id, mitigationStatus, server, stanza, *Verify*\
| eval check= if(mitigationStatus=="mitigated", "mitigated", "vulnerable")\
| stats values(check) AS checked by svd_id\
| eval check = if(checked=="vulnerable" AND checked=="mitigated", "vulnerable", if(checked=="mitigated", "mitigated", "vulnerable")) ] \
| eval check = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), "manual check", check)\
\
``` SVD-2022-0301 requires an extra check  ```\
| join type=left svd_id \
[ | search index="app_eavc" sourcetype="eavc:mc_indexer_tls" (disabled="0" OR disabled="false") tlsEnabled="true" earliest=-14d@d\
| stats values(tlsEnabled) AS tls\
| eval check = if(tls=="true" AND tls=="false", "vulnerable", if(tls=="true", "mitigated", "unknown"))\
| eval svd_id = "SVD-2022-0301"\
| fields svd_id, check ]\
\
| eval check = case(\
    svd_id=="SVD-2022-0607", dsStatus,\
    svd_id="SVD-2022-0608", dsStatus,\
    1==1, check\
    ) \
    ``` TLS verfication checks ``` \
| eval check = case(\
    ``` here we check the lookup "svd_manual_checks" for any manually checked SVDs which we can't automate ```\
    (check=="manual check" AND (checkDone=="yes" OR checkDone=="true" OR checkDone=1)), "mitigated",\
    svd_id=="SVD-2024-0708" AND upgradeNecessary3=="yes" AND upgradeNecessary3=="no", "vulnerable",\
    1==1, check\
    ) \
| eval check = if(note=="none", "no action required", check) \
| eval checked="no"\
| where check LIKE "manual check"\
| stats values(note) AS Notes, values(checked) AS checkDone by svd_id\
| sort - svd_id\
| outputlookup svd_manual_checks

[populate_svd_app_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_app_label_correlation \
| rename app_label AS label \
| join type=left label \
    [ | search index="app_eavc" sourcetype="eavc:mc_apps" earliest=-15d@d ] \
| rename version as currentVersion \
| rex max_match=1 field=currentVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| lookup svd_mitigation svd_id AS svd_id OUTPUTNEW note, is_app\
| where is_app LIKE "true"\
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$"\
``` | rex max_match=5 field=note "(?=\d+)(?P<targetVersion>\d+\.[^\,\s]+)"  ```\
\
| rex max_match=1 field=note "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=note "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=note "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", "") \
| eval upgradeNecessary = if(isnull(currentVersion), "not installed", upgradeNecessary) \
| table svd_id, splunk_server, label, currentVersion, targetVersion, upgradeNecessary, major_a, minor_a, point_a, hotfix_a, major_t, minor_t, point_t, hotfix_t, mitFlag\
| outputlookup svd_app_upgrade_checks

[populate_svd_uf_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| fields - url, is_app \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)"\
    ``` manual checks which can't be checked remote ``` \
| eval doNotUpgradeCheck = case(\
    svd_id=="SVD-2022-0606", "true",\
    1==1, "false"\
    ) \
| where isnotnull(evalUf) AND doNotUpgradeCheck LIKE "false" \
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$"\
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
| fields - doNotUpgradeCheck, alwaysMatch, note \
| lookup svd_uf_versions evalUf AS evalUf OUTPUTNEW version \
| mvexpand version \
| rex max_match=1 field=version "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=version "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=version "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", "") \
| table svd_id, targetVersion, version, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, evalUf, mitFlag\
| sort - svd_id \
| outputlookup svd_uf_upgrade_checks

[populate_svd_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = fast
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| search is_app=false\
    ```\
    the following check excludes some SVDs which refer to TLS verifications which aren't mitigated simply by upgrading to Splunk version X\
    ``` \
| eval doNotUpgradeCheck = case(\
     ``` we exclude the SVD of UBA  ```\
    svd_id=="SVD-2024-0104", "true",\
    1==1, "false"\
    ) \
| where doNotUpgradeCheck LIKE "false"\
    ``` max_match=5 in case we'll ever have even longer Splunk release versions ;) ``` \
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
    ``` here we'll remove trailing dots at version numbers that may otherwise occur ```\
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$" \
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
    ``` exclude SVDs without version ```\
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
    ``` to avoid heavy searches, we simply query the Splunk version from a lookup (which gets populated every hour) ``` \
| lookup svd_splunk_version match AS alwaysMatch OUTPUTNEW getVersion AS getVersion \
    ``` for testing, overwrite getVersion with your eval here: \
| eval getVersion="8.2.6.0" ``` \
| rex max_match=1 field=getVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=getVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=getVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| rex field=note "(?i)(?=splunk\s+enterprise)(?P<evalProduct>\w+\s+\w+)" \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)" \
| rex field=note "(?i)(?=splunk\s+user\s+behavior\s+analytics)(?:\w+\s+)(?P<evalProduct>\w+\s+\w+\s+\w+)" \
    ``` for easier debugging or further development, these statements have been put into seperate evals ```\
    ``` little workaround to avoid dealing with non-existent point/hotfix (x.x.Y or x.x.x.Y) relases ``` \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", if((major_a = major_t) AND (minor_a = minor_t) AND (point_a > point_t), "mitigated", "")) \
| where isnotnull(evalProduct) \
| fields svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix, mitFlag*\
| table svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix, mitFlag*\
| sort - svd_id \
| outputlookup svd_upgrade_checks

[populate_uf_versions]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 5 */2 * * *
dispatch.earliest_time = -60m@m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = ``` Use these two lines instead of index=_internal in case you're running this on a Monitoring Console. ```\
    ``` \
| inputlookup dmc_forwarder_assets \
| search forwarder_type="uf" ```\
\
``` The following search exists in case we can not access the Monitoring Console's forwarder lookup. So we build our own to have reliable results.\
    This scheduled search is deactivated by default in case you have thousands of forwarders. If you have this app installed on your MC, it's more efficient to use the lookup instead. ```\
index=_internal source=*metrics.log* group=tcpin_connections host="*" fwdType="uf" \
| fields - _raw, _time\
| fields hostname, version, os \
| eval evalUf="Universal Forwarder"\
| stats values(os) AS OS by version, evalUf\
| table version, OS, evalUf\
| sort - versions\
| outputlookup svd_uf_versions

[query_splunk_version]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 0 * * * *
description = Writes the Splunk version to a lookup to be used in other searches.
dispatch.earliest_time = -15m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | rest /services/server/info splunk_server=* \
| fields splunk_server, version \
| eval match="true"\
| stats values(version) AS getVersion by match\
| outputlookup svd_splunk_version

[svd_generate_mitigation_report]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */15 * * * *
dispatch.earliest_time = -7d@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = app_eavc
request.ui_dispatch_view = search
search = | inputlookup svd_mitigation_status\
    ``` svd_02_MR-vulnerable_svds ``` \
| search Status="vulnerable" \
| stats count(Status) as count \
| eval check = if(count>0, "fail", "pass") \
| eval name = "svd_02_MR" \
| fields name, check\
\
    ``` svd_03_MR-manual_check_req ``` \
| append \
    [| inputlookup svd_mitigation_status\
        ``` svd_02_MR-vulnerable_svds ``` \
    | search Status="manual check" \
| stats count(Status) as count \
| eval check = if(count>0, "fail", "pass") \
| eval name = "svd_03_MR" \
| fields name, check\
    ]\
    \
    ``` svd_04_MR-indexer_tls ``` \
| append \
    [ | search index="app_eavc" sourcetype="eavc:mc_indexer_tls" (disabled="0" OR disabled="false") tlsEnabled="true" earliest=-14d@d\
| stats count AS counter\
| fillnull counter value="0"\
| eval name = "svd_04_MR" \
| eval check = if(counter > 0, "pass", "fail")\
| fields - counter\
    ]\
    \
    ``` svd_05_MR-webserver_https ``` \
| append \
    [| search index="_internal" sourcetype="splunkd_ui_access" referer="*" \
| rex field=referer "(?P<accessType>[^\:]+)" \
| where accessType IN ("http", "https") \
| stats count by accessType \
| eval name = "svd_05_MR" \
| eval check = if(accessType="http", "fail", "pass") \
| fields name, check\
    ] \
    \
    ``` svd_06_MR-signature_version ``` \
| append \
    [| rest /services/configs/conf-server splunk_server=* \
    | fields splunk_server, title, signatureVersion \
    | search title=node_auth \
    | dedup splunk_server \
    | eval name = "svd_06_MR" \
| eval check = if(signatureVersion=="v2", "pass", "fail") \
| fields name, check ] \
\
    ``` svd_07_MR-python_https ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:python_https" \
| fields host, PYTHONHTTPSVERIFY \
| stats values(PYTHONHTTPSVERIFY) AS PYTHONHTTPSVERIFY by host \
| eval name = "svd_07_MR" \
| eval check = if(PYTHONHTTPSVERIFY="0", "fail", "pass") \
| fields name, check ]\
\
    ``` svd_08_MR-core_supported ``` \
| append \
    [| inputlookup svd_splunk_version \
    | rex field=getVersion "(?<installedVersion>^\d+\.\d+)" \
| fields - match, getVersion \
| lookup svd_splunk_core_supported_versions version AS installedVersion OUTPUTNEW product, release, support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_08_MR" \
| fields name, check] \
\
    ``` svd_09_MR-uf_supported ``` \
| append \
    [| inputlookup svd_uf_versions.csv \
    | rex field=version "(?<installedVersion>^\d+\.\d+)" \
| fields - version \
| lookup svd_splunk_uf_supported_versions version AS installedVersion OUTPUTNEW product, release, support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_09_MR" \
| stats values(check) AS checked by name \
| eval check = if(checked=="fail" AND checked=="pass", "fail", "pass") \
| fields name, check ]\
\
    ``` svd_10_MR-kernel_supported ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:kernel_check" earliest=-14d@d\
| fields kernel_version, host \
| lookup linux_kernel_versions kernel_version AS kernel_version OUTPUTNEW eol \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(eol, "%Y-%m-%d") \
| eval is_supported = if(currentEpoch <= futureEpoch, "yes", "no") \
| stats latest(kernel_version) AS kernel by host, is_supported \
| stats values(is_supported) AS supported \
| eval check = if(supported=="yes" AND supported=="no", "fail", if(supported=="no", "fail", "pass")) \
| eval name = "svd_10_MR" \
| fields name, check ] \
\
    ``` svd_11_MR-es_supported ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_apps" label="Enterprise Security" (disabled="0" OR disabled="false") earliest=-15d@d \
| fields version \
| rex field=version "(?<installedVersion>\d+\.\d+)" \
| lookup svd_splunk_es_supported_versions version AS installedVersion OUTPUTNEW support_end \
| fields support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_11_MR" \
| fields name, check]\
\
    ``` svd_12_MR-itsi_supported ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_apps" label="IT Service Intelligence" (disabled="0" OR disabled="false") earliest=-15d@d \
| fields version \
| rex field=version "(?<installedVersion>\d+\.\d+)" \
| lookup svd_splunk_itsi_supported_versions version AS installedVersion OUTPUTNEW support_end \
| fields support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_12_MR" \
| fields name, check]\
\
    ``` svd_13_MR-ds_dc_auth ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_ds_auth" earliest=-14d@d \
| fields server, stanza, config, requireAuthentication \
| eval DSAuthenticationInUse = case( \
    stanza=="broker:broker" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
    stanza=="streams:deployment" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
    stanza=="broker:broker" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
    stanza=="streams:deployment" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
    1==1, "unknown"\
    ) \
| stats values(DSAuthenticationInUse) AS DSAuthInUse \
| eval name = "svd_13_MR" \
| eval check = case(\
    DSAuthInUse=="no", "fail",\
    DSAuthInUse=="yes", "pass",\
    1==1, "unknown"\
    ) \
| fields name, check]\
\
    ``` svd_14_MR-OS_filesystem_check ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:permission_check" earliest=-14d@d \
| eval parent = "/" \
| eval SPLUNK_HOME = mvzip(parent, splunk_home, "") \
| stats latest(owner) AS owner, latest(group) AS group, latest(u_permissions) AS userPerm latest(g_permissions) AS groupPerm, latest(o_permissions) AS otherPerm, values(SPLUNK_HOME) AS "Splunk Home" by host \
| eval check = case(\
    owner=="root" OR group=="root", "fail",\
    otherPerm=="rwx", "fail",\
    1==1, "pass"\
    )\
    ``` we need to combine the check values due to multiple hosts possibly having differing configurations ``` \
    | stats values(check) AS checked \
    | eval check = if(checked="pass" AND checked!="fail", "pass", "fail") \
| eval name="svd_14_MR" \
| fields name, check]\
\
    ``` svd_15_MR-default-web-cert ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_webserver" earliest=-14d@d \
| fields server, privKeyPath, serverCert \
| fields - _raw \
    ``` due to having leading space(s) ``` \
    | rex field=privKeyPath "(?=etc)(?P<def_key>etc\/auth\/splunkweb\/privkey\.pem)" \
| rex field=serverCert "(?=etc)(?P<def_cert>etc\/auth\/splunkweb\/cert\.pem)" \
| fields - privKeyPath, serverCert \
| eval check = case(\
    ``` checking for default cert being used ```\
        ``` privKeyPath=="etc/auth/splunkweb/privkey.pem" AND serverCert=="etc/auth/splunkweb/cert.pem", "fail", ```\
        def_cert=="etc/auth/splunkweb/cert.pem", "fail",\
    def_key=="etc/auth/splunkweb/privkey.pem", "fail",\
    1==1, "pass"\
    ) \
| stats values(check) AS checked \
| eval check = if(checked=="pass" AND checked=="fail" , "fail", if(checked=="pass" AND checked!="fail", "pass", "fail")) \
| eval name = "svd_15_MR" \
| fields check, name ]\
\
    ``` svd_16_MR-webserver_hardening ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_webserver" earliest=-14d@d\
| fields server, allowSslRenegotiation, sendStrictTransportSecurityHeader, sslVersions, enable_insecure_login, privKeyPath, serverCert \
| eval check = case(\
    allowSslRenegotiation=="1" OR allowSslRenegotiation="enabled", "fail",\
    sendStrictTransportSecurityHeader=="0" OR sendStrictTransportSecurityHeader="disabled", "fail",\
    ``` sslVersions defaults to tls1.2 in newer versions, so we only check for old stuff ```\
        sslVersions=="tls1.1" OR sslVersions="tls1.0" OR sslVersions=="sslv2" OR sslVersions=="sslv3", "fail",\
    enable_insecure_login=="1" OR enable_insecure_login=="enabled", "fail",\
    ``` checking for default cert being used ```\
        1==1, "pass"\
    ) \
| stats values(check) AS checked \
| eval check = if(checked=="pass" AND checked=="fail", "fail", "pass") \
| eval name = "svd_16_MR" \
| fields name, check ] \
\
    ``` svd_17_MR-selinux_status ```\
| append \
[| search index="app_eavc" sourcetype="eavc:selinux" \
| stats latest(sestatus) as lSestatus by host \
| stats values(lSestatus) AS allSestatus \
| eval check = if(allSestatus=="disabled" AND allSestatus=="enabled", "fail", if(allSestatus=="enabled", "pass", "fail" )) \
| eval name = "svd_17_MR" \
| fields name, check ]\
\
    ``` svd_18_MR-uf_mgmt_port ```\
| append [ | search index="app_eavc" sourcetype="eavc:uf_mgmt" disableDefaultPort="true" earliest=-14d@d\
| stats latest(disableDefaultPort) AS disabledDefaultPort \
| eval check = if(disabledDefaultPort=="true", "pass", "fail") \
| eval name = "svd_18_MR" \
| fields name, check ]\
\
\
    ``` svd_19_MR-idx_dic ```\
| append [ | search index=app_eavc sourcetype="eavc:mc_indexer_dic" enableDataIntegrityControl=*  earliest=-14d@d\
| fields * \
| stats latest(indexCount) AS cDIC by enableDataIntegrityControl, totalIndexCount\
| eval check = case(\
enableDataIntegrityControl=="0" AND cDIC=="0", "pass",\
enableDataIntegrityControl=="1" AND cDIC=totalIndexCount, "pass",\
1==1, "fail"\
)\
| stats values(check) AS check\
| eval name = "svd_19_MR" | fields name, check ]\
\
``` svd_20_MR-hec_secure\
trying a different approach here, writing check results directly into the index to preserve processing time in this search ```\
| append [ | search index=app_eavc sourcetype="eavc:mc_hec_status" check=*  earliest=-14d@d \
| eval name= "svd_20_MR"\
| fields name, check]\
\
\
    ``` get a description of every check and a mitigation note (later) ``` \
| lookup svd_mr_ids id AS name, OUTPUTNEW description AS description \
| table name, description, check \
| sort + name \
| rename check AS validation\
| outputlookup svd_mitigation_report.csv

[svd_populate_mitigation_status]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */15 * * * *
dispatch.earliest_time = -60m@m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = app_eavc
request.ui_dispatch_view = search
search = | inputlookup svd_mitigation\
| fields *\
 \
| fields svd_id, note\
    ``` \
    In order to get all SVDs only once, we have seperated the SVDs into Splunk Enterprise, Apps and Universal Forwarders \
    Enterprise = upgradeNecessary, mitFlag\
    Apps/Add-ons = upgradeNecessary2, mitFlag2\
    UFs = upgradeNecessary3, mitFlag3\
    ``` \
| lookup svd_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary, mitFlag \
| lookup svd_app_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary2, mitFlag AS mitFlag2 \
| lookup svd_uf_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary3, mitFlag AS mitFlag3\
    ``` \
    This lookup gets populated by manually(!) running the "populate_manual_checks_lookup" report. After that, put in the lookup which ones you have checked.\
    Or simply modify the report to output a yes in the checkDone column. ``` \
| lookup svd_manual_checks svd_id AS svd_id OUTPUTNEW checkDone AS checkDone \
    ``` \
    The checks here aren't that hard, except for one situation. When we have multiple target releases for a fix AND our version is exactly one of them, we ran into issues in the past. \
    That's why we set an additional flag ONLY if our current version is exactly the same as the required version (as there are probably mutliple fixed versions listed in an SVD). \
    In that case, we don't need all the other release checks.\
    ``` \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary3), upgradeNecessary2, upgradeNecessary) \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), upgradeNecessary3, upgradeNecessary) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag3), mitFlag2, mitFlag) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag2), mitFlag3, mitFlag) \
| eval dd = mvdedup(upgradeNecessary) \
| eval ddMit = mvdedup(mitFlag) \
| fields - mitFlag, mitFlag* \
| eval dd=if(match(ddMit, "mitigated"), "no", if(match(upgradeNecessary, "yes"), "yes", dd)) \
| eval check = case(\
    ``` OLD - need to verify this works now without checking for "no" and "NOT yes": we check for yes AND no due to checking against multiple releases. if one verison has a "yes", we need to upgrade ```\
    ``` dd=="no" AND dd!="yes", "mitigated", ```\
    dd=="no", "mitigated",\
    dd=="yes", "vulnerable",\
    dd=="not installed", "not installed",\
    isnull(dd), "manual check",\
    1==1, "unknown"\
    ) \
    ``` get PYTHONHTTPS ``` \
| join type=left svd_id \
    [| search index=app_eavc sourcetype="eavc:python_https" PYTHONHTTPSVERIFY!="0" earliest=-14d@d \
    | stats latest(PYTHONHTTPSVERIFY) AS status \
    | eval status = case (\
        status=0, "disabled",\
        status=1, "enabled",\
        status=="enabled", status,\
        status=="disabled", status,\
        1==1, "unknown"\
        ) \
    | eval mitigated = case(\
        status=="enabled", "mitigated",\
        status=="disabled", vulnerable,\
        1==1, "unknown"\
        ) \
    | eval svd_id="SVD-2022-0601" \
    | fields svd_id, mitigated \
    | rename mitigated AS pyMitigation ] \
    ``` get Deployment Server authentication-related SVDs \
    SVD-2022-0607, SVD-2022-0608 ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_ds_auth" earliest=-14d@d \
    | fields server, stanza, config, requireAuthentication \
    | eval DSAuthenticationInUse = case( \
        stanza=="broker:broker" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="streams:deployment" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="broker:broker" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        stanza=="streams:deployment" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        1==1, "unknown"\
        ) \
    | eval svd_id= mvappend("SVD-2022-0608", "SVD-2022-0607") \
    | stats values(DSAuthenticationInUse) AS DSAuthInUse by svd_id \
    | table svd_id, DSAuthInUse \
    | eval check = case(\
        DSAuthInUse=="no", "vulnerable",\
        DSAuthInUse=="yes", "mitigated",\
        1==1, "unknown"\
        ) \
    | fields svd_id, check ] \
    ``` SVD-2022-0601, SVD-2022-0602, SVD-2022-0603, SVD-2022-0606 ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_tls_verification" stanza="*" server="*"  earliest=-14d@d\
    | fields svd_id, mitigationStatus, server, stanza, *Verify* \
    | table svd_id, mitigationStatus, server, stanza, *Verify* \
    | eval check= if(mitigationStatus=="mitigated", "mitigated", "vulnerable") \
    | stats values(check) AS checked by svd_id \
    | eval check = if(checked=="vulnerable" AND checked=="mitigated", "vulnerable", if(checked=="mitigated", "mitigated", "vulnerable")) ] \
| eval check = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), "manual check", check)\
    ``` SVD-2022-0301 requires an extra check ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_indexer_tls" (disabled="0" OR disabled="false") tlsEnabled="true" earliest=-14d@d \
    | stats values(tlsEnabled) AS tls \
    | eval check = if(tls=="true" AND tls=="false", "vulnerable", if(tls=="true", "mitigated", "unknown")) \
    | eval svd_id = "SVD-2022-0301" \
    | fields svd_id, check ] \
| eval check = case(\
    ``` here we check the lookup "svd_manual_checks" for any manually checked SVDs which we can't automate ```\
    (check=="manual check" AND (checkDone=="yes" OR checkDone=="true" OR checkDone=1)), "mitigated",\
    svd_id=="SVD-2024-0708" AND upgradeNecessary3=="yes" AND upgradeNecessary3=="no", "vulnerable",\
    1==1, check\
    ) \
| eval check = if(note=="none", "no action required", check) \
| fields svd_id, check \
| sort - svd_id \
| table svd_id, check\
| rename svd_id AS SVD, check AS Status\
| outputlookup svd_mitigation_status

