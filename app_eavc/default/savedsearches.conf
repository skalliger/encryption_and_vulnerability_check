[default]
[generate_sva_mapping]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 0 6 * * *
description = Try to get a Splunk Validated Architectures (SVA) mapping if possible.
dispatch.earliest_time = -14d@d
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = app_eavc
request.ui_dispatch_view = search
search = index="app_eavc" sourcetype="eavc:mc_environment"  earliest=-14d@d\
| eval manager_uri = if(isnull(manager_uri), master_uri, manager_uri) \
\
``` we don't check for DS, CM, LM as it's irrelevant ```\
| eval aioFlag = if(match(server_roles, "indexer") AND match(server_roles, "license_manager") AND isForwarding=="0" AND manager_uri=="self", "true", "false")\
| eval shFlag = if(match(server_roles, "search_head") AND NOT match(server_roles, "cluster_manager"), "true", "false") \
| eval idxFlag = if(match(server_roles, "indexer") AND NOT match(server_roles, "cluster_peer"), "true", "false") \
| eval idxcFlag = if(match(server_roles, "indexer") AND match(server_roles, "cluster_peer"), "true", "false") \
| eval shcFlag = if(match(server_roles, "shc_deployer") OR match(server_roles, "shc_member"), "true", "false") \
| fields - _raw \
| fields *Flag \
|  stats values(aioFlag) AS aio, values(idxFlag) AS idx, values(idxcFlag) AS idxc, values(shFlag) AS sh, values(shcFlag) AS shc\
\
``` let's clear false flags when true was evaluated also, we just need to know if something is in the environment ```\
| eval idx = if(idx=="false" AND idx=="true", "true", idx)\
| eval idxc = if(idxc=="false" AND idxc=="true", "true", idxc)\
| eval sh = if(sh=="false" AND sh=="true", "true", sh)\
| eval shc = if(shc=="false" AND shc=="true", "true", shc)\
\
| join type=left \
    [| search index="app_eavc" sourcetype="eavc:mc_query_cm_sites" earliest=-14d@d title="manager"\
    | fields sites, multisite, title\
    | eval multiFlag = if(multisite=="true" AND sites>1, "true", "false") \
    | fields multiFlag ] \
    \
``` in case you wonder, app_eavc in the search below is just a trick to get a higher SH count returned because I don't expect it to run on the ES/ITSI SH ```\
| join type=left\
    [ | search index="app_eavc" sourcetype="eavc:mc_apps" title IN ("itsi", "SplunkEnterpriseSecuritySuite", "app_eavc") earliest=-14d@d\
| eventstats dc(server) AS hostCount \
| eval checked = if(title=="itsi" OR title=="SplunkEnterpriseSecuritySuite", "true", "false") \
| stats values(checked) AS check by hostCount\
| eval plus_ten = if(hostCount>1 AND check=="true", "true", "false")\
| fields plus_ten ]\
\
``` this join needs testing with an actual SHC (site0) and two SHCs in two sites ```\
| join type=left\
    [ | search index="app_eavc" sourcetype="eavc:mc_shc_parameters" earliest=-14d@d \
| fields site, multisite\
| stats values(site) AS sites, values(multisite) AS ms\
    |  fields ms, sites]\
| eval stretchedSHC = if(sites=="0", "true", "false")\
| eval multipleSHC = if(sites!="0" AND ms=="true", "true", "false")\
\
``` Now, this is where it gets interesting.\
    I don't really have an idea what to do with that mapping to an SVA yet but we'll find something eventually. Creating the search was fun. \
    \
    In case you want an explanation:\
    aio = this is an all in one instance (S1 in SVA terms)\
    multiFlag - describes indexer sites. Some clusters are set-up as multisite but only have one site, so if multisite is true but only one site available, this is false for me\
    shc/idxc - if a cluster of SHs or IDXs was found\
    plus_ten - searches the installed apps for ITSI/ES and if found, will do the +10 for an SVA (e.g. M13 instead of M3)\
    stretchedSHC - whether a SHC has its site set to "site0" (M4/M14) or not (M3/M13), for C3/C13 the flag is optional (just not checking the flag here)\
    multipleSHC - is there more than one SHC? because there could be multiple SHC but only one IDXC, that's why we can't rely on that    \
    ```    \
    \
| eval sva = case(\
aio=="true", "S1",\
shc=="true" AND multiFlag=="true" AND idxc=="true" AND plus_ten=="false" AND stretchedSHC=="false" AND multipleSHC=="true", "M3",\
shc=="true" AND multiFlag=="true" AND idxc=="true" AND plus_ten=="true" AND stretchedSHC=="false" AND multipleSHC=="true", "M13",\
shc=="false" AND sh=="true" AND multiFlag=="true" AND idxc=="true" AND plus_ten=="false" AND stretchedSHC=="false" AND multipleSHC=="false", "M2",\
shc=="false" AND sh=="true" AND multiFlag=="true" AND idxc=="true" AND plus_ten=="true" AND stretchedSHC=="false" AND multipleSHC=="false", "M12",\
shc=="true" AND multiFlag=="true" AND idxc=="true" AND plus_ten=="false" AND stretchedSHC=="true" AND multipleSHC=="false", "M4",\
shc=="true" AND multiFlag=="true" AND idxc=="true" AND plus_ten=="true" AND stretchedSHC=="true" AND multipleSHC=="false", "M14",\
shc=="true" AND idxc=="true" AND multiFlag=="false" AND plus_ten=="false" AND multipleSHC=="false", "C3",\
shc=="true" AND idxc=="true" AND multiFlag=="false" AND plus_ten=="true" AND multipleSHC=="false", "C13",\
shc=="false" AND sh=="true" AND idxc=="true" AND multiFlag=="false" AND plus_ten=="false" AND multipleSHC=="false", "C1",\
shc=="false" AND sh=="true" AND idxc=="true" AND multiFlag=="false" AND plus_ten=="true" AND multipleSHC=="false", "C11",\
(shc=="true" OR sh=="true") AND idxc=="false" AND idx=="true" AND multiFlag=="false" AND plus_ten=="false" AND multipleSHC=="false", "D1",\
(shc=="true" OR sh=="true") AND idxc=="false" AND idx=="true" AND multiFlag=="false" AND plus_ten=="true" AND multipleSHC=="false", "D11",\
1==1, "unknown")    \
\
| fields sva, *\
| outputlookup sva.csv

[populate_linux_kernel_lookup]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = * */12 * * *
dispatch.earliest_time = 0
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 0
request.ui_dispatch_app = app_eavc
request.ui_dispatch_view = search
search = index=app_eavc sourcetype="eavc:kernel_versions"\
| table kernel_version, releaseDate, latest, latestReleaseDate, lts, eol, \
| sort - releaseDate\
``` | outputlookup linux_kernel_versions.csv ```

[populate_manual_checks_lookup]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
description = Run this Check once and set checkDone to yes after confirming the configs.
dispatch.earliest_time = @d
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
search = | inputlookup svd_mitigation\
| fields svd_id, note\
    ``` \
    In order to get all SVDs only once, we have seperated the SVDs into Splunk Enterprise, Apps and Universal Forwarders \
    Enterprise = upgradeNecessary, mitFlag\
    Apps/Add-ons = upgradeNecessary2, mitFlag2\
    UFs = upgradeNecessary3, mitFlag3\
    ``` \
| lookup svd_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary, mitFlag \
| lookup svd_app_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary2, mitFlag AS mitFlag2 \
| lookup svd_uf_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary3, mitFlag AS mitFlag3\
    ``` \
    This lookup gets populated by manually(!) running the "populate_manual_checks_lookup" report. After that, put in the lookup which ones you have checked.\
    Or simply modify the report to output a yes in the checkDone column. ``` \
| lookup svd_manual_checks svd_id AS svd_id OUTPUTNEW checkDone AS checkDone \
    ``` \
    The checks here aren't that hard, except for one situation. When we have multiple target releases for a fix AND our version is exactly one of them, we ran into issues in the past. \
    That's why we set an additional flag ONLY if our current version is exactly the same as the required version (as there are probably mutliple fixed versions listed in an SVD). \
    In that case, we don't need all the other release checks.\
    ``` \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary3), upgradeNecessary2, upgradeNecessary) \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), upgradeNecessary3, upgradeNecessary) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag3), mitFlag2, mitFlag) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag2), mitFlag3, mitFlag) \
| eval dd = mvdedup(upgradeNecessary) \
| eval ddMit = mvdedup(mitFlag) \
| fields - mitFlag, mitFlag* \
| eval dd=if(match(ddMit, "mitigated"), "no", if(match(upgradeNecessary, "yes"), "yes", dd)) \
| eval check = case(\
    ``` OLD - need to verify this works now without checking for "no" and "NOT yes": we check for yes AND no due to checking against multiple releases. if one verison has a "yes", we need to upgrade ```\
    ``` dd=="no" AND dd!="yes", "mitigated", ```\
    dd=="no", "mitigated",\
    dd=="yes", "vulnerable",\
    dd=="not installed", "not installed",\
    isnull(dd), "manual check",\
    1==1, "unknown"\
    ) \
    ``` get PYTHONHTTPS ``` \
| join type=left svd_id \
    [| search index=app_eavc sourcetype="eavc:python_https" PYTHONHTTPSVERIFY!="0" earliest=-14d@d \
    | stats latest(PYTHONHTTPSVERIFY) AS status \
    | eval status = case (\
        status=0, "disabled",\
        status=1, "enabled",\
        status=="enabled", status,\
        status=="disabled", status,\
        1==1, "unknown"\
        ) \
    | eval mitigated = case(\
        status=="enabled", "mitigated",\
        status=="disabled", vulnerable,\
        1==1, "unknown"\
        ) \
    | eval svd_id="SVD-2022-0601" \
    | fields svd_id, mitigated \
    | rename mitigated AS pyMitigation ] \
    ``` get Deployment Server authentication-related SVDs ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_ds_auth" earliest=-14d@d \
    | fields server, stanza, config, requireAuthentication \
    | eval DSAuthenticationInUse = case( \
        stanza=="broker:broker" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="streams:deployment" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="broker:broker" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        stanza=="streams:deployment" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        1==1, "unknown"\
        ) \
    | eval svd_id= mvappend("SVD-2022-0608", "SVD-2022-0607") \
    | stats values(DSAuthenticationInUse) AS DSAuthInUse by svd_id \
    | table svd_id, DSAuthInUse \
    | eval dsStatus = case(\
        DSAuthInUse=="no", "vulnerable",\
        DSAuthInUse=="yes", "mitigated",\
        1==1, "unknown"\
        ) \
    | fields svd_id, dsStatus ] \
``` SVD-2022-0601, SVD-2022-0602, SVD-2022-0603, SVD-2022-0606 ```\
| join type=left svd_id \
    [ | search index="app_eavc" sourcetype="eavc:mc_tls_verification" stanza="*" server="*" earliest=-14d@d\
| fields svd_id, mitigationStatus, server, stanza, *Verify*\
| table svd_id, mitigationStatus, server, stanza, *Verify*\
| eval check= if(mitigationStatus=="mitigated", "mitigated", "vulnerable")\
| stats values(check) AS checked by svd_id\
| eval check = if(checked=="vulnerable" AND checked=="mitigated", "vulnerable", if(checked=="mitigated", "mitigated", "vulnerable")) ] \
| eval check = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), "manual check", check)\
\
``` SVD-2022-0301 requires an extra check  ```\
| join type=left svd_id \
[ | search index="app_eavc" sourcetype="eavc:mc_indexer_tls" (disabled="0" OR disabled="false") tlsEnabled="true" earliest=-14d@d\
| stats values(tlsEnabled) AS tls\
| eval check = if(tls=="true" AND tls=="false", "vulnerable", if(tls=="true", "mitigated", "unknown"))\
| eval svd_id = "SVD-2022-0301"\
| fields svd_id, check ]\
\
| eval check = case(\
    svd_id=="SVD-2022-0607", dsStatus,\
    svd_id="SVD-2022-0608", dsStatus,\
    1==1, check\
    ) \
    ``` TLS verfication checks ``` \
| eval check = case(\
    ``` here we check the lookup "svd_manual_checks" for any manually checked SVDs which we can't automate ```\
    (check=="manual check" AND (checkDone=="yes" OR checkDone=="true" OR checkDone=1)), "mitigated",\
    svd_id=="SVD-2024-0708" AND upgradeNecessary3=="yes" AND upgradeNecessary3=="no", "vulnerable",\
    1==1, check\
    ) \
| eval check = if(note=="none", "no action required", check) \
| eval checked="no"\
| where check LIKE "manual check"\
| stats values(note) AS Notes, values(checked) AS checkDone by svd_id\
| sort - svd_id\
| outputlookup svd_manual_checks

[populate_svd_app_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_app_label_correlation \
| rename app_label AS label \
| join type=left label \
    [ | search index="app_eavc" sourcetype="eavc:mc_apps" earliest=-15d@d ] \
| rename version as currentVersion \
| rex max_match=1 field=currentVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| lookup svd_mitigation svd_id AS svd_id OUTPUTNEW note, is_app\
| where is_app LIKE "true"\
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$"\
``` | rex max_match=5 field=note "(?=\d+)(?P<targetVersion>\d+\.[^\,\s]+)"  ```\
\
| rex max_match=1 field=note "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=note "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=note "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", "") \
| eval upgradeNecessary = if(isnull(currentVersion), "not installed", upgradeNecessary) \
| table svd_id, server, label, currentVersion, targetVersion, upgradeNecessary, major_a, minor_a, point_a, hotfix_a, major_t, minor_t, point_t, hotfix_t, mitFlag\
| outputlookup svd_app_upgrade_checks

[populate_svd_uf_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| fields - url, is_app \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)"\
\
| where isnotnull(evalUf) \
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$"\
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
| fields - doNotUpgradeCheck, alwaysMatch, note, title, severity, cve, date\
\
| lookup svd_uf_versions evalUf AS evalUf OUTPUTNEW version \
| mvexpand version \
| rex max_match=1 field=version "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=version "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=version "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
\
\
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
\
``` testing ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a >= point_t) AND (hotfix_a >= hotfix_t), "mitigated", "")\
\
| eval comparable = if((major_a = major_t) AND (minor_a = minor_t), "yes", "no")\
\
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    ``` (checkMajor=="equal") AND (checkMinor=="abort"), "yes", ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
| fields - check*, *_a, *_t\
``` I was refactoring this search to only save SVDs where comparable=true and get rid of unneeded checks, so the check field actually can be removed\
    but for now I'll keep it in case other weird checks appear in the future ```\
| eval check = case(\
comparable=="no" AND (upgradeNecessary=="yes" OR upgradeNecessary=="unknown"), "-",\
comparable=="yes" AND upgradeNecessary=="yes", "yes",\
comparable=="no" AND upgradeNecessary=="no", "-",\
comparable=="yes" AND mitFlag="mitigated", "no",\
1==1, "unknown")\
| table svd_id, * \
| sort - svd_id\
| outputlookup svd_uf_upgrade_checks

[populate_svd_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = fast
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| search is_app=false\
    ```\
    the following check excludes some SVDs which refer to TLS verifications which aren't mitigated simply by upgrading to Splunk version X\
    ``` \
| eval doNotUpgradeCheck = case(\
     ``` we exclude the SVD of UBA  ```\
    svd_id=="SVD-2024-0104", "true",\
    1==1, "false"\
    ) \
| where doNotUpgradeCheck LIKE "false"\
    ``` max_match=5 in case we'll ever have even longer Splunk release versions ;) ``` \
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
    ``` here we'll remove trailing dots at version numbers that may otherwise occur ```\
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$" \
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
    ``` exclude SVDs without version ```\
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
    ``` to avoid heavy searches, we simply query the Splunk version from a lookup (which gets populated every hour) ``` \
| lookup svd_splunk_version match AS alwaysMatch OUTPUTNEW getVersion AS getVersion \
    ``` for testing, overwrite getVersion with your eval here: \
| eval getVersion="8.2.6.0" ``` \
| rex max_match=1 field=getVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=getVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=getVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| rex field=note "(?i)(?=splunk\s+enterprise)(?P<evalProduct>\w+\s+\w+)" \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)" \
| rex field=note "(?i)(?=splunk\s+user\s+behavior\s+analytics)(?:\w+\s+)(?P<evalProduct>\w+\s+\w+\s+\w+)" \
    ``` for easier debugging or further development, these statements have been put into seperate evals ```\
    ``` little workaround to avoid dealing with non-existent point/hotfix (x.x.Y or x.x.x.Y) relases ``` \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", if((major_a = major_t) AND (minor_a = minor_t) AND (point_a > point_t), "mitigated", "")) \
| where isnotnull(evalProduct) \
| fields svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix, mitFlag*\
| table svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix, mitFlag*\
| sort - svd_id \
| outputlookup svd_upgrade_checks

[populate_uf_versions]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 5 */2 * * *
dispatch.earliest_time = -4h@m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = index=_internal source=*metrics.log* group=tcpin_connections host="*" fwdType="uf" \
| fields - _raw, _time\
| fields hostname, version, os \
| eval evalUf="Universal Forwarder"\
| stats values(os) AS OS by version, evalUf\
| table version, OS, evalUf\
| sort - versions\
| outputlookup svd_uf_versions

[query_splunk_version]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 0 * * * *
description = Writes the Splunk version to a lookup to be used in other searches.
dispatch.earliest_time = -15m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | rest /services/server/info splunk_server=* \
| fields splunk_server, version \
| eval match="true"\
| stats values(version) AS getVersion by match\
| outputlookup svd_splunk_version

[svd_generate_hardening_report]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */15 * * * *
dispatch.earliest_time = -7d@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = app_eavc
request.ui_dispatch_view = search
search = | inputlookup svd_mitigation_status\
``` svd_02_MR-vulnerable_svds ``` \
| search Status="vulnerable" \
| stats count(Status) as count \
| eval check = if(count>0, "fail", "pass") \
| eval name = "svd_02_MR" \
| fields name, check\
\
``` svd_03_MR-manual_check_req ``` \
| append \
    [| inputlookup svd_mitigation_status\
        ``` svd_02_MR-vulnerable_svds ``` \
    | search Status="manual check" \
| stats count(Status) as count \
| eval check = if(count>0, "fail", "pass") \
| eval name = "svd_03_MR" \
| fields name, check\
    ]\
\
``` svd_04_MR-indexer_tls ``` \
| append \
    [ | search index="app_eavc" sourcetype="eavc:mc_indexer_tls" (disabled="0" OR disabled="false") tlsEnabled="true" earliest=-14d@d \
| stats count AS counter \
| fillnull counter value="0" \
| eval name = "svd_04_MR" \
| eval check = if(counter > 0, "pass", "fail") \
| fields - counter\
    ]\
\
``` svd_05_MR-webserver_https ``` \
| append \
    [| search index="_internal" sourcetype="splunkd_ui_access" referer="*" earliest=-4h@h \
| rex field=referer "(?P<accessType>[^\:]+)" \
| where accessType IN ("http", "https") \
| stats count by accessType \
| eval name = "svd_05_MR" \
| eval check = if(accessType="http", "fail", "pass") \
| fields name, check\
    ] \
\
``` svd_06_MR-signature_version ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_sig_version" earliest=-14d@d signatureVersion=* \
| stats values(signatureVersion) AS sigs \
| eval check = case(\
    sigs=="v1,v2" AND sigs!="v2", "fail",\
    sigs=="v2" AND sigs!="v1,v2", "pass",\
    check=="pass", "pass",\
    1==1, "fail") \
| eval name = "svd_06_MR" \
| fields name, check ] \
\
``` svd_07_MR-python_https ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:python_https" earliest=-14d@d \
| fields host, PYTHONHTTPSVERIFY \
| stats values(PYTHONHTTPSVERIFY) AS PYTHONHTTPSVERIFY by host \
| eval check = if(PYTHONHTTPSVERIFY="0", "fail", "pass") \
| stats values(check) AS checked \
| eval check = if(checked=="pass" AND checked!="fail", "pass", "fail") \
| eval name = "svd_07_MR" \
| fields name, check ]\
\
``` svd_08_MR-core_supported ``` \
| append \
    [| inputlookup svd_splunk_version \
    | rex field=getVersion "(?<installedVersion>^\d+\.\d+)" \
| fields - match, getVersion \
| lookup svd_splunk_core_supported_versions version AS installedVersion OUTPUTNEW product, release, support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_08_MR" \
| fields name, check] \
\
``` svd_09_MR-uf_supported ``` \
| append \
    [| inputlookup svd_uf_versions.csv \
    | rex field=version "(?<installedVersion>^\d+\.\d+)" \
| fields - version \
| lookup svd_splunk_uf_supported_versions version AS installedVersion OUTPUTNEW product, release, support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_09_MR" \
| stats values(check) AS checked by name \
| eval check = if(checked=="fail" AND checked=="pass", "fail", "pass") \
| fields name, check ]\
\
``` svd_10_MR-kernel_supported ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_environment" server="*" kernel_version=* \
| fields kernel_version, server \
| lookup linux_kernel_versions kernel_version AS kernel_version, OUTPUTNEW eol \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(eol, "%Y-%m-%d") \
| eval is_supported = if(currentEpoch <= futureEpoch, "yes", "no") \
| stats latest(kernel_version) AS kernel by server, is_supported \
| stats values(is_supported) AS supported \
| eval check = if(supported=="yes" AND supported=="no", "fail", if(supported=="no" AND supported!="yes", "fail", "pass")) \
| eval name = "svd_10_MR" \
| fields name, check ] \
\
``` svd_11_MR-es_supported ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_apps" label="Enterprise Security" (disabled="0" OR disabled="false") earliest=-15d@d \
| fields version \
| rex field=version "(?<installedVersion>\d+\.\d+)" \
| lookup svd_splunk_es_supported_versions version AS installedVersion OUTPUTNEW support_end \
| fields support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_11_MR" \
| fields name, check]\
\
``` svd_12_MR-itsi_supported ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_apps" label="IT Service Intelligence" (disabled="0" OR disabled="false") earliest=-15d@d \
| fields version \
| rex field=version "(?<installedVersion>\d+\.\d+)" \
| lookup svd_splunk_itsi_supported_versions version AS installedVersion OUTPUTNEW support_end \
| fields support_end \
| eval currDate = strftime(now(), "%Y-%m-%d") \
| eval currentEpoch = strptime(currDate, "%Y-%m-%d") \
| eval futureEpoch = strptime(support_end, "%Y-%m-%d") \
| eval check = if(currentEpoch <= futureEpoch, "pass", "fail") \
| eval name = "svd_12_MR" \
| fields name, check]\
\
``` svd_13_MR-ds_dc_auth ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_ds_auth" earliest=-14d@d \
| fields server, stanza, config, requireAuthentication \
| eval DSAuthenticationInUse = case( \
    stanza=="broker:broker" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
    stanza=="streams:deployment" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
    stanza=="broker:broker" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
    stanza=="streams:deployment" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
    1==1, "unknown"\
    ) \
| stats values(DSAuthenticationInUse) AS DSAuthInUse \
| eval name = "svd_13_MR" \
| eval check = case(\
    DSAuthInUse=="no", "fail",\
    DSAuthInUse=="yes", "pass",\
    1==1, "unknown"\
    ) \
| fields name, check]\
\
``` svd_14_MR-OS_filesystem_check ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:permission_check" earliest=-14d@d splunk_home=* \
| stats latest(permissions) AS perm, latest(splunk_home) AS splunkHome, latest(owner) AS Owner, latest(group) AS Group by host \
| eval check = case(\
    (perm=="750" OR perm=="0750" OR perm=="700" OR perm=="0700") AND (Owner!="root" AND Group!="root"), "pass",\
    1==1, "fail"\
    )\
    ``` we need to combine the check values due to multiple hosts possibly having differing configurations ``` \
    | stats values(check) AS checked \
    | eval check = if(checked="pass" AND checked!="fail", "pass", "fail") \
| eval name="svd_14_MR" \
| fields name, check]\
\
``` svd_15_MR-default-web-cert ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_webserver" earliest=-14d@d \
| fields server, privKeyPath, serverCert \
| fields - _raw \
    ``` due to having leading space(s) ``` \
    | rex field=privKeyPath "(?=etc)(?P<def_key>etc\/auth\/splunkweb\/privkey\.pem)" \
| rex field=serverCert "(?=etc)(?P<def_cert>etc\/auth\/splunkweb\/cert\.pem)" \
| fields - privKeyPath, serverCert \
| eval check = case(\
    ``` checking for default cert being used ```\
        ``` privKeyPath=="etc/auth/splunkweb/privkey.pem" AND serverCert=="etc/auth/splunkweb/cert.pem", "fail", ```\
        def_cert=="etc/auth/splunkweb/cert.pem", "fail",\
    def_key=="etc/auth/splunkweb/privkey.pem", "fail",\
    1==1, "pass"\
    ) \
| stats values(check) AS checked \
| eval check = if(checked=="pass" AND checked=="fail" , "fail", if(checked=="pass" AND checked!="fail", "pass", "fail")) \
| eval name = "svd_15_MR" \
| fields check, name ]\
\
``` svd_16_MR-webserver_hardening ``` \
| append \
    [| search index="app_eavc" sourcetype="eavc:mc_webserver" earliest=-14d@d \
| fields server, allowSslRenegotiation, sendStrictTransportSecurityHeader, sslVersions, enable_insecure_login, privKeyPath, serverCert \
| eval check = case(\
    allowSslRenegotiation=="1" OR allowSslRenegotiation="enabled", "fail",\
    sendStrictTransportSecurityHeader=="0" OR sendStrictTransportSecurityHeader="disabled", "fail",\
    ``` sslVersions defaults to tls1.2 in newer versions, so we only check for old stuff ```\
        sslVersions=="tls1.1" OR sslVersions="tls1.0" OR sslVersions=="sslv2" OR sslVersions=="sslv3", "fail",\
    enable_insecure_login=="1" OR enable_insecure_login=="enabled", "fail",\
    ``` checking for default cert being used ```\
        1==1, "pass"\
    ) \
| stats values(check) AS checked \
| eval check = case(\
    checked=="pass" AND checked=="fail", "fail",\
    checked=="fail" AND checked!="pass", "fail",\
    checked!="fail" AND checked="pass", "pass",\
    1==1, "fail"\
    ) \
| eval name = "svd_16_MR" \
| fields name, check ] \
\
``` svd_17_MR-selinux_status ```\
| append \
[| search index="app_eavc" sourcetype="eavc:selinux" \
| stats latest(sestatus) as lSestatus by host \
| stats values(lSestatus) AS allSestatus \
| eval check = if(allSestatus=="disabled" AND allSestatus=="enabled", "fail", if(allSestatus=="enabled", "pass", "fail" )) \
| eval name = "svd_17_MR" \
| fields name, check ]\
\
``` svd_18_MR-uf_mgmt_port ```\
| append [ | search index="app_eavc" sourcetype="eavc:uf_mgmt" disableDefaultPort="true" earliest=-14d@d \
| stats latest(disableDefaultPort) AS disabledDefaultPort \
| eval check = if(disabledDefaultPort=="true", "pass", "fail") \
| eval name = "svd_18_MR" \
| fields name, check ]\
\
``` svd_19_MR-idx_dic ```\
| append [ | search index=app_eavc sourcetype="eavc:mc_indexer_dic" enableDataIntegrityControl=* earliest=-14d@d \
| fields * \
| stats latest(indexCount) AS cDIC by enableDataIntegrityControl, totalIndexCount \
| eval check = case(\
    enableDataIntegrityControl=="0" AND cDIC=="0", "pass",\
    enableDataIntegrityControl=="1" AND cDIC=totalIndexCount, "pass",\
    1==1, "fail"\
    ) \
| stats values(check) AS check \
| eval name = "svd_19_MR" \
| fields name, check ]\
\
``` svd_20_MR-hec_secure\
trying a different approach here, writing check results directly into the index to preserve processing time in this search ```\
| append [ | search index=app_eavc sourcetype="eavc:mc_hec_status" check=* earliest=-14d@d \
| stats latest(check) AS checked \
| eval name= "svd_20_MR" \
| fields name, checked \
| rename checked as check ]\
\
``` svd_21_MR-indexer_web_disabled ```\
| append [ | search index="app_eavc" sourcetype="eavc:mc_environment" \
| fields server, server_roles \
| rex field=server_roles "(?<peer>indexer)" \
| rex field=server_roles "(?<peer2>cluster_peer)" \
| eval search_peer = if(isnull(peer2) OR peer2=="", peer, peer2) \
| eval is_peer = if(isnull(search_peer) OR search_peer=="", "false", "true") \
| fields - peer, peer2 \
| where is_peer=="true" \
| fields server \
| join type=left server \
[| rest /services/configs/conf-web splunk_server=* \
| search title="settings" \
| fields splunk_server title, startwebserver \
| rename splunk_server AS server \
    ] \
| stats c AS counter by startwebserver \
| eval check = if(startwebserver=1 AND counter>1, "fail", if(startwebserver="0" AND counter>0, "pass", if(startwebserver=1 AND counter=1, "N.A. (single instance)", "fail"))) \
| eval name = "svd_21_MR" \
| fields name, check ]\
\
``` svd_22_MR-base_apps ```\
| append [ | search index="app_eavc" sourcetype="eavc:mc_apps" NOT title IN ("DA-ESS*", "DA-ITSI*", "Splunk_*", "search", "splunk-*", "itsi", "SA-*") earliest=-14d@d \
| fields title \
| stats values(title) AS apps \
| mvexpand apps \
| where match(apps, "(?<org>^[a-z]{2,5})(?:_)(?<target>[a-zA-Z0-9]{2,10})(?:_)(?<descriptive_name>[a-zA-Z_0-9]{2,30})") \
| stats c AS counter \
| eval check = if(counter>0, "pass", "fail") \
| eval name = "svd_22_MR" \
| fields - counter ]\
\
``` svd_23_MR-nacls ```\
| append [ \
``` We do NOT check for udp:// and tcp:// because usually those are not used. If they are used, it's not best practice anyway.\
   I could add another check for [shclustering] in here, but SHCs aren't that common\
1/4 - httpServer ```\
| search index="app_eavc" sourcetype="eavc:mc_webserver" earliest=-14d@d \
| fields acceptFrom \
| stats values(acceptFrom) as af1\
    \
``` 2/4 - splunktcp and 3/4 splunktcp-ssl  ```\
| append [ | search index="app_eavc" sourcetype="eavc:mc_indexer_tls" stanza="splunktcp*" earliest=-14d@d \
| fields acceptFrom \
| stats values(acceptFrom) AS af2 ]\
    ``` 4/4 - http ```\
| append [ | search index="app_eavc" sourcetype="eavc:mc_hec_status" earliest=-14d@d \
| fields acceptFrom \
| stats values(acceptFrom) AS af3 ] \
| eval check = case(\
    match(af1, "\*"), "fail",\
    match(af2, "\*"), "fail",\
    match(af3, "\*"), "fail",\
    1==1, "pass"\
    ) \
| stats values(check) AS checked \
| eval check = if(checked=="fail" AND checked="pass", "fail", if(checked=="pass" AND checked!="fail", "pass", "fail")) \
| eval name = "svd_23_MR" \
| fields name, check\
    ]\
    \
``` svd_24_MR-mail_domains ```\
| append [ | rest /services/configs/conf-alert_actions splunk_server=local \
| search title="email" \
| fields allowedDomainList, splunk_server \
| eval check = if(isnull(allowedDomainList) OR allowedDomainList="", "fail", "pass") \
| eval name = "svd_24_MR" \
| fields name, check ]\
\
``` svd_25_MR-ntp ```\
| append [ | search index=app_eavc sourcetype="eavc:ntp" ntp_service_status=* OR clock_synced=* \
| stats latest(ntp_service_status) as ntpStatusH, latest(clock_synced) AS inSyncH by host \
| stats values(ntpStatusH) as ntpStatus, values(inSyncH) AS inSync \
| eval check = case (\
``` TO-DO: need to check timedatectl for disabled/inactive ntp service ```\
ntpStatus=="active" AND inSync=="yes" AND ntpStatus!="inactive" AND inSync!="no", "pass",\
    1==1, "fail") \
| eval name = "svd_25_MR" \
| fields name, check ] \
\
``` svd_26_MR-sva ```\
| append \
[| inputlookup sva \
| fields sva \
| eval name = "svd_26_MR" \
| eval check = if(sva=="unknown", "fail", "pass") ]\
\
    ``` get a description of every check ``` \
| lookup svd_hr_ids id AS name, OUTPUTNEW description AS description \
| table name, description, check \
| sort + name \
| rename check AS validation \
| outputlookup svd_hardening_report.csv

[svd_populate_mitigation_status]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */15 * * * *
dispatch.earliest_time = -60m@m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = app_eavc
request.ui_dispatch_view = search
search = | inputlookup svd_mitigation\
| fields *\
 \
| fields svd_id, note\
    ``` \
    In order to get all SVDs only once, we have seperated the SVDs into Splunk Enterprise, Apps and Universal Forwarders \
    Enterprise = upgradeNecessary, mitFlag\
    Apps/Add-ons = upgradeNecessary2, mitFlag2\
    UFs = upgradeNecessary3, mitFlag3\
    ``` \
| lookup svd_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary, mitFlag \
| lookup svd_app_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary2, mitFlag AS mitFlag2 \
| lookup svd_uf_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary3, mitFlag AS mitFlag3\
    ``` \
    This lookup gets populated by manually(!) running the "populate_manual_checks_lookup" report. After that, put in the lookup which ones you have checked.\
    Or simply modify the report to output a yes in the checkDone column. ``` \
| lookup svd_manual_checks svd_id AS svd_id OUTPUTNEW checkDone AS checkDone \
    ``` \
    The checks here aren't that hard, except for one situation. When we have multiple target releases for a fix AND our version is exactly one of them, we ran into issues in the past. \
    That's why we set an additional flag ONLY if our current version is exactly the same as the required version (as there are probably mutliple fixed versions listed in an SVD). \
    In that case, we don't need all the other release checks.\
    ``` \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary3), upgradeNecessary2, upgradeNecessary) \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), upgradeNecessary3, upgradeNecessary) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag3), mitFlag2, mitFlag) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag2), mitFlag3, mitFlag) \
| eval dd = mvdedup(upgradeNecessary) \
| eval ddMit = mvdedup(mitFlag) \
| fields - mitFlag, mitFlag* \
| eval dd=if(match(ddMit, "mitigated"), "no", if(match(upgradeNecessary, "yes"), "yes", dd)) \
| eval check = case(\
    ``` OLD - need to verify this works now without checking for "no" and "NOT yes": we check for yes AND no due to checking against multiple releases. if one verison has a "yes", we need to upgrade ```\
    ``` dd=="no" AND dd!="yes", "mitigated", ```\
    dd=="no", "mitigated",\
    dd=="yes", "vulnerable",\
    dd=="not installed", "not installed",\
    isnull(dd), "manual check",\
    1==1, "unknown"\
    ) \
    ``` get PYTHONHTTPS ``` \
| join type=left svd_id \
    [| search index=app_eavc sourcetype="eavc:python_https" PYTHONHTTPSVERIFY!="0" earliest=-14d@d \
    | stats latest(PYTHONHTTPSVERIFY) AS status \
    | eval status = case (\
        status=0, "disabled",\
        status=1, "enabled",\
        status=="enabled", status,\
        status=="disabled", status,\
        1==1, "unknown"\
        ) \
    | eval mitigated = case(\
        status=="enabled", "mitigated",\
        status=="disabled", vulnerable,\
        1==1, "unknown"\
        ) \
    | eval svd_id="SVD-2022-0601" \
    | fields svd_id, mitigated \
    | rename mitigated AS pyMitigation ] \
    ``` get Deployment Server authentication-related SVDs \
    SVD-2022-0607, SVD-2022-0608 ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_ds_auth" earliest=-14d@d \
    | fields server, stanza, config, requireAuthentication \
    | eval DSAuthenticationInUse = case( \
        stanza=="broker:broker" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="streams:deployment" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        stanza=="broker:broker" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        stanza=="streams:deployment" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        1==1, "unknown"\
        ) \
    | eval svd_id= mvappend("SVD-2022-0608", "SVD-2022-0607") \
    | stats values(DSAuthenticationInUse) AS DSAuthInUse by svd_id \
    | table svd_id, DSAuthInUse \
    | eval check = case(\
        DSAuthInUse=="no", "vulnerable",\
        DSAuthInUse=="yes", "mitigated",\
        1==1, "unknown"\
        ) \
    | fields svd_id, check ] \
    ``` SVD-2022-0601, SVD-2022-0602, SVD-2022-0603, SVD-2022-0606 ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_tls_verification" stanza="*" server="*"  earliest=-14d@d\
    | fields svd_id, mitigationStatus, server, stanza, *Verify* \
    | table svd_id, mitigationStatus, server, stanza, *Verify* \
    | eval check= if(mitigationStatus=="mitigated", "mitigated", "vulnerable") \
    | stats values(check) AS checked by svd_id \
    | eval check = if(checked=="vulnerable" AND checked=="mitigated", "vulnerable", if(checked=="mitigated", "mitigated", "vulnerable")) ] \
| eval check = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), "manual check", check)\
    ``` SVD-2022-0301 requires an extra check ``` \
| join type=left svd_id \
    [| search index="app_eavc" sourcetype="eavc:mc_indexer_tls" (disabled="0" OR disabled="false") tlsEnabled="true" earliest=-14d@d \
    | stats values(tlsEnabled) AS tls \
    | eval check = if(tls=="true" AND tls=="false", "vulnerable", if(tls=="true", "mitigated", "unknown")) \
    | eval svd_id = "SVD-2022-0301" \
    | fields svd_id, check ] \
| eval check = case(\
    ``` here we check the lookup "svd_manual_checks" for any manually checked SVDs which we can't automate ```\
    (check=="manual check" AND (checkDone=="yes" OR checkDone=="true" OR checkDone=1)), "mitigated",\
    svd_id=="SVD-2024-0708" AND upgradeNecessary3=="yes" AND upgradeNecessary3=="no", "vulnerable",\
    1==1, check\
    ) \
| eval check = if(note=="none", "no action required", check) \
| fields svd_id, check \
| sort - svd_id \
| table svd_id, check\
| rename svd_id AS SVD, check AS Status\
| outputlookup svd_mitigation_status

