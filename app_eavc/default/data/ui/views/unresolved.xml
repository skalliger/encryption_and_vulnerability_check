
<dashboard version="2" theme="dark">
    <label>Unresolved</label>
    <description></description>
    <definition><![CDATA[
{
	"visualizations": {
		"viz_qtnKB7rq": {
			"type": "splunk.table",
			"options": {
				"columnFormat": {
					"Fix": {
						"width": 256
					},
					"severity": {
						"width": 40
					},
					"SVD": {
						"width": 63
					},
					"Status": {
						"width": 45
					},
					"title": {
						"width": 276
					},
					"Description": {
						"width": 235
					},
					"Severity": {
						"width": 54,
						"data": "> table | seriesByName(\"Severity\") | formatByType(SeverityColumnFormatEditorConfig)",
						"rowColors": "> table | seriesByName(\"Severity\") | matchValue(SeverityRowColorsEditorConfig)"
					}
				},
				"showInternalFields": false,
				"count": 12,
				"fontSize": "large"
			},
			"dataSources": {
				"primary": "ds_qNPtPK6w"
			},
			"context": {
				"SeverityColumnFormatEditorConfig": {
					"string": {
						"unitPosition": "after"
					}
				},
				"SeverityRowColorsEditorConfig": [
					{
						"match": "Info",
						"value": "#555555"
					},
					{
						"match": "Low",
						"value": "#207865"
					},
					{
						"match": "Medium",
						"value": "#AD3F20"
					},
					{
						"match": "High",
						"value": "#78062a"
					},
					{
						"match": "Critical",
						"value": "#78062A"
					}
				]
			}
		}
	},
	"dataSources": {
		"ds_qNPtPK6w": {
			"type": "ds.search",
			"options": {
				"query": "| inputlookup svd_mitigation \n| fields *\n    ``` \n    In order to get all SVDs only once, we have seperated the SVDs into Splunk Enterprise, Apps and Universal Forwarders \n    Enterprise = upgradeNecessary, mitFlag\n    Apps/Add-ons = upgradeNecessary2, mitFlag2\n    UFs = upgradeNecessary3, mitFlag3\n    ``` \n| lookup svd_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary, mitFlag \n| lookup svd_app_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary2, mitFlag AS mitFlag2 \n| lookup svd_uf_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary3, mitFlag AS mitFlag3\n    ``` \n    This lookup gets populated by manually(!) running the \"populate_manual_checks_lookup\" report. After that, put in the lookup which ones you have checked.\n    Or simply modify the report to output a yes in the checkDone column. ``` \n| lookup svd_manual_checks svd_id AS svd_id OUTPUTNEW checkDone AS checkDone \n    ``` \n    The checks here aren't that hard, except for one situation. When we have multiple target releases for a fix AND our version is exactly one of them, we ran into issues in the past. \n    That's why we set an additional flag ONLY if our current version is exactly the same as the required version (as there are probably mutliple fixed versions listed in an SVD). \n    In that case, we don't need all the other release checks.\n    ``` \n| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary3), upgradeNecessary2, upgradeNecessary) \n| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), upgradeNecessary3, upgradeNecessary) \n| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag3), mitFlag2, mitFlag) \n| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag2), mitFlag3, mitFlag) \n| eval dd = mvdedup(upgradeNecessary) \n| eval ddMit = mvdedup(mitFlag) \n| fields - mitFlag, mitFlag* \n| eval dd=if(match(ddMit, \"mitigated\"), \"no\", if(match(upgradeNecessary, \"yes\"), \"yes\", dd)) \n| eval check = case(\n    ``` OLD - need to verify this works now without checking for \"no\" and \"NOT yes\": we check for yes AND no due to checking against multiple releases. if one verison has a \"yes\", we need to upgrade ```\n    ``` dd==\"no\" AND dd!=\"yes\", \"mitigated\", ```\n    dd==\"no\", \"mitigated\",\n    dd==\"yes\", \"vulnerable\",\n    dd==\"not installed\", \"not installed\",\n    isnull(dd), \"manual check\",\n    1==1, \"unknown\"\n    ) \n    ``` get PYTHONHTTPS ``` \n| join type=left svd_id \n    [| search index=app_eavc sourcetype=\"eavc:python_https\" PYTHONHTTPSVERIFY!=\"0\" earliest=-14d@d \n| stats latest(PYTHONHTTPSVERIFY) AS status \n| eval status = case (\n    status=0, \"disabled\",\n    status=1, \"enabled\",\n    status==\"enabled\", status,\n    status==\"disabled\", status,\n    1==1, \"unknown\"\n    ) \n| eval mitigated = case(\n    status==\"enabled\", \"mitigated\",\n    status==\"disabled\", vulnerable,\n    1==1, \"unknown\"\n    ) \n| eval svd_id=\"SVD-2022-0601\" \n| fields svd_id, mitigated \n| rename mitigated AS pyMitigation ] \n    ``` get Deployment Server authentication-related SVDs \n    SVD-2022-0607, SVD-2022-0608 ``` \n| join type=left svd_id \n    [| search index=\"app_eavc\" sourcetype=\"eavc:mc_ds_auth\" earliest=-14d@d \n| fields server, stanza, config, requireAuthentication \n| eval DSAuthenticationInUse = case( \n    stanza==\"broker:broker\" AND (requireAuthentication=0 OR requireAuthentication==\"false\"), \"no\",\n    stanza==\"streams:deployment\" AND (requireAuthentication=0 OR requireAuthentication==\"false\"), \"no\",\n    stanza==\"broker:broker\" AND (requireAuthentication=1 OR requireAuthentication==\"true\"), \"yes\",\n    stanza==\"streams:deployment\" AND (requireAuthentication=1 OR requireAuthentication==\"true\"), \"yes\",\n    1==1, \"unknown\"\n    ) \n| eval svd_id= mvappend(\"SVD-2022-0608\", \"SVD-2022-0607\") \n| stats values(DSAuthenticationInUse) AS DSAuthInUse by svd_id \n| table svd_id, DSAuthInUse \n| eval check = case(\n    DSAuthInUse==\"no\", \"vulnerable\",\n    DSAuthInUse==\"yes\", \"mitigated\",\n    1==1, \"unknown\"\n    ) \n| fields svd_id, check ] \n    ``` SVD-2022-0601, SVD-2022-0602, SVD-2022-0603, SVD-2022-0606 ``` \n| join type=left svd_id \n    [| search index=\"app_eavc\" sourcetype=\"eavc:mc_tls_verification\" stanza=\"*\" server=\"*\" earliest=-14d@d \n| fields svd_id, mitigationStatus, server, stanza, *Verify* \n| table svd_id, mitigationStatus, server, stanza, *Verify* \n| eval check= if(mitigationStatus==\"mitigated\", \"mitigated\", \"vulnerable\") \n| stats values(check) AS checked by svd_id \n| eval check = if(checked==\"vulnerable\" AND checked==\"mitigated\", \"vulnerable\", if(checked==\"mitigated\", \"mitigated\", \"vulnerable\")) ] \n| eval check = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), \"manual check\", check)\n    ``` SVD-2022-0301 requires an extra check ``` \n| join type=left svd_id \n    [| search index=\"app_eavc\" sourcetype=\"eavc:mc_indexer_tls\" (disabled=\"0\" OR disabled=\"false\") tlsEnabled=\"true\" earliest=-14d@d \n| stats values(tlsEnabled) AS tls \n| eval check = if(tls==\"true\" AND tls==\"false\", \"vulnerable\", if(tls==\"true\", \"mitigated\", \"unknown\")) \n| eval svd_id = \"SVD-2022-0301\" \n| fields svd_id, check ] \n| eval check = case(\n    ``` here we check the lookup \"svd_manual_checks\" for any manually checked SVDs which we can't automate ```\n    (check==\"manual check\" AND (checkDone==\"yes\" OR checkDone==\"true\" OR checkDone=1)), \"mitigated\",\n    svd_id==\"SVD-2024-0708\" AND upgradeNecessary3==\"yes\" AND upgradeNecessary3==\"no\", \"vulnerable\",\n    1==1, check\n    ) \n| eval check = if(note==\"none\", \"no action required\", check) \n| fields svd_id, check, severity, title, note, cve, url \n| sort - svd_id \n| table svd_id, check, severity, title, note, cve, url \n| rename svd_id AS SVD, check AS Status, note AS \"Fix\", title AS \"Description\", cve AS CVE, severity AS Severity, url AS \"Additional Information\"\n| where Status LIKE \"vulnerable\"",
				"queryParameters": {
					"earliest": "-24h@h",
					"latest": "now"
				}
			},
			"name": "list_vulnerable_svds"
		}
	},
	"defaults": {
		"dataSources": {
			"ds.search": {
				"options": {
					"queryParameters": {
						"latest": "$global_time.latest$",
						"earliest": "$global_time.earliest$"
					}
				}
			}
		}
	},
	"inputs": {},
	"layout": {
		"type": "grid",
		"options": {
			"width": 1440,
			"height": 960
		},
		"structure": [
			{
				"item": "viz_qtnKB7rq",
				"type": "block",
				"position": {
					"x": 0,
					"y": 0,
					"w": 1440,
					"h": 604
				}
			}
		],
		"globalInputs": []
	},
	"description": "",
	"title": "Unresolved"
}
    ]]></definition>
    <meta type="hiddenElements"><![CDATA[
{
	"hideEdit": false,
	"hideOpenInSearch": false,
	"hideExport": false
}
    ]]></meta>
</dashboard>