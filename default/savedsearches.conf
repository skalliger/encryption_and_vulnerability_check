[default]
[populate_manual_checks_lookup]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
description = Run this Check once and set checkDone to yes after confirming the configs.
dispatch.earliest_time = @d
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.tab = statistics
display.visualizations.show = 0
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
search = | inputlookup svd_mitigation\
| fields *\
| search severity IN (*)\
 \
| fields svd_id, note\
    ``` in order to get all SVDs only once, we have seperated the SVDs into Splunk Enterprise, Apps and Universal Forwarders \
    Enterprise = upgradeNecessary, mitFlag\
    Apps/Add-ons = upgradeNecessary2, mitFlag2\
    UFs = upgradeNecessary3, mitFlag3\
    ``` \
| lookup svd_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary, mitFlag \
| lookup svd_app_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary2, mitFlag AS mitFlag2 \
| lookup svd_uf_upgrade_checks svd_id AS svd_id OUTPUTNEW upgradeNecessary AS upgradeNecessary3, mitFlag AS mitFlag3\
    ``` \
    The checks here aren't that hard, except for one situation. When we have multiple target releases for a fix AND our version is exactly one of them, we ran into issues in the past. \
    That's why we set an additional flag ONLY if our current version is exactly the same as the required version (as there are probably mutliple fixed versions listed in an SVD). \
    In that case, we don't need all the other release checks.\
    ``` \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary3), upgradeNecessary2, upgradeNecessary) \
| eval upgradeNecessary = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), upgradeNecessary3, upgradeNecessary) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag3), mitFlag2, mitFlag) \
| eval mitFlag = if(isnull(mitFlag) AND isnull(mitFlag2), mitFlag3, mitFlag) \
| eval dd = mvdedup(upgradeNecessary) \
| eval ddMit = mvdedup(mitFlag) \
| fields - mitFlag, mitFlag* \
| eval dd=if(match(ddMit, "mitigated"), "no", if(match(upgradeNecessary, "yes"), "yes", dd)) \
| eval check = case(\
    ``` OLD - need to verify this works now without checking for "no" and "NOT yes": we check for yes AND no due to checking against multiple releases. if one verison has a "yes", we need to upgrade ```\
    ``` dd=="no" AND dd!="yes", "mitigated", ```\
    dd=="no", "mitigated",\
    dd=="yes", "vulnerable",\
    dd=="not installed", "not installed",\
    isnull(dd), "manual check",\
    1==1, "unknown"\
    ) \
    ``` get PYTHONHTTPS ``` \
| join type=left svd_id \
    [| inputlookup pythonhttps_status \
    | eval status = case (\
        status=0, "disabled",\
        status=1, "enabled",\
        status=="enabled", status,\
        status=="disabled", status,\
        1==1, "unknown"\
        ) \
    | eval mitigated = case(\
        status=="enabled", "mitigated",\
        status=="disabled", vulnerable,\
        1==1, "unknown"\
        ) \
    | eval svd_id="SVD-2022-0601" \
    | fields svd_id, mitigated \
    | rename mitigated AS pyMitigation ] \
    ``` get Deployment Server authentication-related SVDs ``` \
| join type=left svd_id \
    [| rest /services/configs/conf-restmap splunk_server=* \
        ``` join to only get the DS ``` \
    | join splunk_server \
        [| rest /services/server/roles splunk_server=* \
        | search role_list=deployment_server \
        | fields splunk_server ] \
    | fields title, splunk_server, requireAuthentication \
    | search title="broker:broker" OR title="streams:deployment" \
    | eval config="restmap.conf" \
    | table splunk_server, config, title, requireAuthentication\
        ``` check for the use of DS authentication ``` \
    | eval DSAuthenticationInUse = case( \
        title=="broker:broker" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        title=="streams:deployment" AND (requireAuthentication=0 OR requireAuthentication=="false"), "no",\
        title=="broker:broker" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        title=="streams:deployment" AND (requireAuthentication=1 OR requireAuthentication=="true"), "yes",\
        1==1, "unknown"\
        ) \
    | eval svd_id= mvappend("SVD-2022-0608", "SVD-2022-0607") \
    | stats values(DSAuthenticationInUse) AS DSAuthInUse by svd_id \
    | table svd_id, DSAuthInUse \
    | eval dsStatus = case(\
        DSAuthInUse=="no", "vulnerable",\
        DSAuthInUse=="yes", "mitigated",\
        1==1, "unknown"\
        ) \
    | fields svd_id, dsStatus ] \
| join type=left svd_id \
    [| rest /services/configs/conf-server splunk_server=* \
    | search title IN ("pythonSslClientConfig", "kvstore", "sslConfig") \
    | fields title, splunk_server, *Verify* \
    | eval mitigationStatus = case(\
        title=="sslConfig" AND (cliVerifyServerName=1 OR cliVerifyServerName=="true") AND (sslVerifyServerCert=1 OR sslVerifyServerCert=="true") AND (sslVerifyServerName=1 OR sslVerifyServerName=="true"), "mitigated",\
        ``` Splunk v.9.0.5: somehow there is no default for \
        [ sslConfig] sslVerifyServerCert, so we have to check for isnull() as well ```\
        title=="sslConfig" AND (cliVerifyServerName=0 OR cliVerifyServerName=="false") AND (sslVerifyServerCert=0 OR sslVerifyServerCert=="false" OR isnull(sslVerifyServerCert)) AND (sslVerifyServerName=0 OR sslVerifyServerName=="false"), "vulnerable", \
        title=="kvstore" AND (sslVerifyServerCert=1 OR sslVerifyServerCert=="true") AND (sslVerifyServerName=1 OR sslVerifyServerName=="true"), "mitigated",\
        title=="kvstore" AND (sslVerifyServerCert=0 OR sslVerifyServerCert=="false") AND (sslVerifyServerName=0 OR sslVerifyServerName=="false"), "vulnerable", \
        title=="pythonSslClientConfig" AND (sslVerifyServerCert=1 OR sslVerifyServerCert=="true") AND (sslVerifyServerName=1 OR sslVerifyServerName=="true"), "mitigated",\
        title=="pythonSslClientConfig" AND (sslVerifyServerCert=0 OR sslVerifyServerCert=="false") AND (sslVerifyServerName=0 OR sslVerifyServerName=="false"), "vulnerable", \
        1==1, "unknown"\
        ) \
    | eval config="server.conf" \
    | eval svd_id = case(\
        title=="sslConfig", mvappend("SVD-2022-0602", "SVD-2022-0603", "SVD-2022-0606"),\
        title=="kvstore", mvappend("SVD-2022-0602", "SVD-2022-0603"),\
        title=="pythonSslClientConfig", "SVD-2022-0601", \
        1==1, "unknown"\
        ) \
    | mvexpand svd_id \
    | stats values(mitigationStatus) AS tlsStatus by svd_id ] \
| eval check = if(isnull(upgradeNecessary) AND isnull(upgradeNecessary2), "manual check", check)\
    ``` These are informational SVDs with no action required ``` \
    ``` these are the joined SVDs with custom checks (see appends above).\
    This way we override the old check (which is in state "manual" and thus can remove all events with empty checks later on.``` \
| eval check = case(\
    svd_id=="SVD-2022-0607", dsStatus,\
    svd_id="SVD-2022-0608", dsStatus,\
    1==1, check\
    ) \
    ``` TLS verfication checks ``` \
| eval check = case(\
    ``` SVD-2022-0601 is special as it requires multiple config checks\
    We could output something like "halfway mitigated" but this gets people confused. So if PYTHONHTTPSVERIFY is enabled but \
    [ pythonSslClientConfig] checks have failed, we will still show it as vulnerable. \
    ```\
    svd_id=="SVD-2022-0606", tlsStatus,\
    ``` svd_id=="SVD-2022-0603", tlsStatus,\
    svd_id=="SVD-2022-0602", tlsStatus, ```\
    ``` INFO: Currently kv store sslVerifyServerName is NOT working, so we set this to mitigated if sslVerifyServerCert is enabled, otherwise this is misleading ```\
    svd_id=="SVD-2022-0603" AND (tlsStatus=="mitigated vulnerable"), "mitigated",\
    svd_id=="SVD-2022-0602" AND (tlsStatus=="mitigated vulnerable"), "mitigated",\
    svd_id=="SVD-2022-0601" AND (pyMitigation=="mitigated") AND (tlsStatus=="mitigated"), "mitigated",\
    svd_id=="SVD-2022-0601" AND (pyMitigation=="mitigated") AND (tlsStatus=="vulnerable"), tlsStatus,\
    svd_id=="SVD-2022-0601" AND (pyMitigation=="vulnerable") AND (tlsStatus=="mitigated"), pyMitigation,\
    svd_id=="SVD-2022-0601" AND (pyMitigation=="vulnerable") AND (tlsStatus=="vulnerable"), "vulnerable",\
    1==1, check\
    ) \
| eval check = if(note=="none", "no action required", check) \
| eval checked="no"\
| where check LIKE "manual check"\
| stats values(note) AS Notes, values(checked) AS checkDone by svd_id\
| sort - svd_id\
| outputlookup svd_manual_checks

[populate_svd_app_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_app_label_correlation \
| rename app_label AS label \
| join type=left label \
    [| rest /services/apps/local splunk_server=* \
    | fields label, version \
    | search NOT label IN ("journald_input", "Home", "learned", "legacy", "Splunk Assist", "Apps Browser", "*Forwarder", "Instrumentation", "*Alert Action", "Search & Reporting", "introspection*", "sample data", "*RapidDiag" ) \
    | eval version = if(isnull(version), "none", version) ] \
| rename version as currentVersion \
| rex max_match=1 field=currentVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| lookup svd_mitigation svd_id AS svd_id OUTPUTNEW note \
\
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$"\
``` | rex max_match=5 field=note "(?=\d+)(?P<targetVersion>\d+\.[^\,\s]+)"  ```\
\
| rex max_match=1 field=note "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=note "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=note "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", "") \
| eval upgradeNecessary = if(isnull(currentVersion), "not installed", upgradeNecessary) \
| table svd_id, label, currentVersion, targetVersion, upgradeNecessary, major_a, minor_a, point_a, hotfix_a, major_t, minor_t, point_t, hotfix_t, mitFlag\
| outputlookup svd_app_upgrade_checks

[populate_svd_uf_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| fields - url, is_app \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)"\
    ``` manual checks which can't be checked remote ``` \
| eval doNotUpgradeCheck = case(\
    svd_id=="SVD-2022-0606", "true",\
    1==1, "false"\
    ) \
| where isnotnull(evalUf) AND doNotUpgradeCheck LIKE "false" \
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$"\
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
| fields - doNotUpgradeCheck, alwaysMatch, note \
| lookup svd_uf_versions evalUf AS evalUf OUTPUTNEW version \
| mvexpand version \
| rex max_match=1 field=version "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=version "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=version "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", "") \
| table svd_id, targetVersion, version, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, evalUf, mitFlag\
| sort - svd_id \
| outputlookup svd_uf_upgrade_checks

[populate_svd_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = fast
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| search is_app=false\
    ```\
    the following check excludes some SVDs which refer to TLS verifications which aren't mitigated simply by upgrading to Splunk version X\
    ``` \
| eval doNotUpgradeCheck = case(\
    svd_id=="SVD-2022-0608", "true",\
    svd_id=="SVD-2022-0607", "true",\
    svd_id=="SVD-2022-0606", "true",\
    svd_id=="SVD-2022-0603", "true",\
    svd_id=="SVD-2022-0602", "true",\
    svd_id=="SVD-2022-0601", "true",\
    1==1, "false"\
    ) \
| where doNotUpgradeCheck LIKE "false"\
    ``` max_match=5 in case we'll ever have even longer Splunk release versions ;) ``` \
| rex max_match=5 field=note "(?=\d+)(?P<tv_temp>\d+\.[^\,\s]+)" \
| mvexpand tv_temp \
    ``` here we'll remove trailing dots at version numbers that may otherwise occur ```\
| rex field=tv_temp "^(?P<targetVersion>.*?)\.?$" \
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
    ``` exclude SVDs without version ```\
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
    ``` to avoid heavy searches, we simply query the Splunk version from a lookup (which gets populated every hour) ``` \
| lookup svd_splunk_version match AS alwaysMatch OUTPUTNEW getVersion AS getVersion \
    ``` for testing, overwrite getVersion with your eval here: \
| eval getVersion="8.2.6.0" ``` \
| rex max_match=1 field=getVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=getVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=getVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| rex field=note "(?i)(?=splunk\s+enterprise)(?P<evalProduct>\w+\s+\w+)" \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)" \
    ``` for easier debugging or further development, these statements have been put into seperate evals ```\
    ``` little workaround to avoid dealing with non-existent point/hotfix (x.x.Y or x.x.x.Y) relases ``` \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
    ``` in later testing, I realised that we need a fix if we have multiple version checks for the same SVD ID. It's not enough to simply check for a "update required" flag ```\
| eval mitFlag = if((major_a = major_t) AND (minor_a = minor_t) AND (point_a = point_t) AND (hotfix_a = hotfix_t), "mitigated", "") \
| where isnotnull(evalProduct) \
| fields svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix, mitFlag\
| table svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix, mitFlag\
| sort - svd_id \
| outputlookup svd_upgrade_checks

[populate_uf_versions]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 5 */2 * * *
dispatch.earliest_time = -60m@m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = ``` Use these two lines instead of index=_internal in case you're running this on a Monitoring Console. ```\
    ``` \
| inputlookup dmc_forwarder_assets \
| search forwarder_type="uf" ```\
\
``` The following search exists in case we can not access the Monitoring Console's forwarder lookup. So we build our own to have reliable results.\
    This scheduled search is deactivated by default in case you have thousands of forwarders. If you have this app installed on your MC, it's more efficient to use the lookup instead. ```\
index=_internal source=*metrics.log* group=tcpin_connections host="*" fwdType="uf" \
| fields - _raw, _time\
| fields hostname, version, os \
| eval evalUf="Universal Forwarder"\
| stats values(os) AS OS by version, evalUf\
| table version, OS, evalUf\
| sort - versions\
| outputlookup svd_uf_versions

[query_splunk_version]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 0 * * * *
description = Writes the Splunk version to a lookup to be used in other searches.
dispatch.earliest_time = -15m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | rest /services/server/info splunk_server=* \
| fields splunk_server, version \
| eval match="true"\
| stats values(version) AS getVersion by match\
| outputlookup svd_splunk_version

