[populate_svd_app_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_app_label_correlation \
| rename app_label AS label \
| join type=left label \
    [| rest /services/apps/local splunk_server=* \
    | fields label, version \
    | search NOT label IN ("journald_input", "Home", "learned", "legacy", "Splunk Assist", "Apps Browser", "*Forwarder", "Instrumentation", "*Alert Action", "Search & Reporting", "introspection*", "sample data", "*RapidDiag" ) \
    | eval version = if(isnull(version), "none", version) ] \
| rename version as currentVersion \
| rex max_match=1 field=currentVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex max_match=1 field=currentVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| lookup svd_mitigation svd_id AS svd_id OUTPUTNEW note \
| rex max_match=5 field=note "(?=\d+)(?P<targetVersion>\d+\.[^\,\s]+)" \
| rex max_match=1 field=note "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=note "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=note "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = if(isnull(currentVersion), "not installed", upgradeNecessary) \
| table svd_id, label, currentVersion, targetVersion, upgradeNecessary, major_a, minor_a, point_a, hotfix_a, major_t, minor_t, point_t, hotfix_t \
| outputlookup svd_app_upgrade_checks

[populate_svd_uf_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| fields - url, is_app \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)"\
    ``` manual checks which can't be checked remote ``` \
| eval doNotUpgradeCheck = case(\
    svd_id=="SVD-2022-0606", "true",\
    svd_id=="SVD-2022-0605", "true",\
    1==1, "false"\
    ) \
| where isnotnull(evalUf) AND doNotUpgradeCheck LIKE "false" \
| rex max_match=5 field=note "(?=\d+)(?P<targetVersion>\d+\.[^\,\s]+)" \
| mvexpand targetVersion \
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
| fields - doNotUpgradeCheck, alwaysMatch, note \
| lookup svd_uf_versions evalUf AS evalUf OUTPUTNEW version \
| mvexpand version \
| rex max_match=1 field=version "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=version "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=version "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)" \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
| table svd_id, targetVersion, version, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, evalUf\
| sort - svd_id \
| outputlookup svd_uf_upgrade_checks

[populate_svd_upgrade_checks]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = */30 * * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = fast
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | inputlookup svd_mitigation \
| search is_app=false\
    ```\
    the following check excludes some SVDs which refer to TLS verifications which aren't mitigated simply by upgrading to Splunk v9\
    ``` \
| eval doNotUpgradeCheck = case(\
    svd_id=="SVD-2022-0608", "true",\
    svd_id=="SVD-2022-0607", "true",\
    svd_id=="SVD-2022-0606", "true",\
    ``` 2022-0605 requires manual check ```\
    svd_id=="SVD-2022-0605", "true",\
    svd_id=="SVD-2022-0603", "true",\
    svd_id=="SVD-2022-0602", "true",\
    svd_id=="SVD-2022-0601", "true",\
    1==1, "false"\
    ) \
| where doNotUpgradeCheck LIKE "false"\
    ``` max_match=5 in case we'll ever have even longer Splunk release versions ;) ``` \
| rex max_match=5 field=note "(?=\d+)(?P<targetVersion>\d+\.[^\,\s]+)" \
| mvexpand targetVersion \
| rex max_match=1 field=targetVersion "(?P<major_t>\d+)(?:\.)(?P<minor_t>\d+)" \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.)(?P<point_t>\d+)"\
    ``` this is where it gets a little complicated, we may have a x.x.x.Y release that we may need to compare, so save it for a check later on ``` \
| rex max_match=1 field=targetVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_t>\d+)" \
``` exclude SVDs without version ```\
| eval alwaysMatch = if(len(targetVersion)=0, "false", "true") \
| where alwaysMatch LIKE "true" \
    ``` to avoid heavy searches, we simply query the Splunk version from a lookup (which gets populated every hour) ``` \
| lookup svd_splunk_version match AS alwaysMatch OUTPUTNEW getVersion AS getVersion \
    ``` for testing, overwrite getVersion with your eval here: \
| eval getVersion="8.2.6.0" ``` \
| rex max_match=1 field=getVersion "(?P<major_a>\d+)(?:\.)(?P<minor_a>\d+)" \
| rex max_match=1 field=getVersion "(?:\d+\.\d+\.)(?P<point_a>\d+)" \
| rex field=getVersion "(?:\d+\.\d+\.\d+\.)(?P<hotfix_a>\d+)"\
| rex field=note "(?i)(?=splunk\s+enterprise)(?P<evalProduct>\w+\s+\w+)" \
| rex field=note "(?i)(?=Universal Forwarder)(?P<evalUf>\w+\s+[^s\s,]+)" \
    ``` for easier debugging or further development, these statements have been put into seperate evals ```\
    ``` little workaround to avoid dealing with non-existent point/hotfix (x.x.Y or x.x.x.Y) relases ``` \
| eval hotfix_t = if(isnull(hotfix_t), "-1", hotfix_t) \
| eval hotfix_a = if(isnull(hotfix_a), "-1", hotfix_a) \
| eval point_t = if(isnull(point_t), "-1", point_t) \
| eval point_a = if(isnull(point_a), "-1", point_a) \
| eval checkMajor = case(\
    major_a > major_t, "complete",\
    major_a = major_t, "equal",\
    major_a < major_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkMinor = case(\
    minor_a > minor_t, "complete",\
    ``` check for non-existent point release ```\
    ```(minor_a = minor_t) AND (point_a = point_t), "complete", ```\
    minor_a = minor_t, "equal",\
    minor_a < minor_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkPoint = case(\
    point_a > point_t, "complete",\
    point_a = point_t, "equal",\
    point_a < point_t, "abort",\
    1=1, "unknown"\
    ) \
| eval checkHotfix = case(\
    hotfix_a > hotfix_t, "complete",\
    ``` careful, this one is different, we don't need further checks if hotfix of the actual version equals the target hotfix version of Splunk ```\
    hotfix_a = hotfix_t, "complete",\
    hotfix_a < hotfix_t, "abort", \
    1=1, "unknown"\
    ) \
| eval upgradeNecessary = case(\
    checkMajor=="complete", "no",\
    checkMajor=="abort", "yes",\
    (checkMajor=="equal") AND (checkMinor=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="abort"), "yes",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="abort"), "yes",\
    ``` check hotfix ```\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="complete"), "no",\
    (checkMajor=="equal") AND (checkMinor=="equal") AND (checkPoint=="equal") AND (checkHotfix=="abort"), "yes",\
    1=1, "unknown"\
    ) \
\
| where isnotnull(evalProduct) \
| fields svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix \
| table svd_id, evalProduct, evalUf, targetVersion, getVersion, upgradeNecessary, major_t, minor_t, point_t, hotfix_t, major_a, minor_a, point_a, hotfix_a, checkMajor, checkMinor, checkPoint, checkHotfix \
| sort - svd_id \
| outputlookup svd_upgrade_checks

[populate_uf_versions]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 5 */2 * * *
dispatch.earliest_time = -24h@h
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = ``` Use these two lines instead of index=_internal in case you're running this on a Monitoring Console. ```\
    ``` \
| inputlookup dmc_forwarder_assets \
| search forwarder_type="uf" ```\
\
``` The following search exists in case we can not access the Monitoring Console's forwarder lookup. So we build our own to have reliable results.\
    This scheduled search is deactivated by default in case you have thousands of forwarders. If you have this app installed on your MC, it's more efficient to use the lookup instead. ```\
index=_internal source=*metrics.log* group=tcpin_connections host="*" fwdType="uf" \
| fields - _raw, _time\
| fields hostname, version, os \
| eval evalUf="Universal Forwarder"\
| stats values(os) AS OS by version, evalUf\
| table version, OS, evalUf\
| sort - versions\
| outputlookup svd_uf_versions

[query_splunk_version]
action.email.useNSSubject = 1
action.webhook.enable_allowlist = 0
alert.track = 0
cron_schedule = 0 * * * *
description = Writes the Splunk version to a lookup to be used in other searches.
dispatch.earliest_time = -15m
dispatch.latest_time = now
display.general.timeRangePicker.show = 0
display.general.type = statistics
display.page.search.mode = verbose
display.page.search.tab = statistics
display.visualizations.show = 0
enableSched = 1
request.ui_dispatch_app = encryption_and_vulnerability_check
request.ui_dispatch_view = search
schedule_window = auto
search = | rest /services/server/info splunk_server=* \
| fields splunk_server, version \
| eval match="true"\
| stats values(version) AS getVersion by match\
| outputlookup svd_splunk_version

